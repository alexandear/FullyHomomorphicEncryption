% !TeX spellcheck = en_US

\documentclass[a4paper, 12pt]{article}

\usepackage{cmap}
\usepackage[utf8]{inputenc}
\usepackage{yfonts}

\usepackage{fixltx2e}

\input glyphtounicode
\pdfgentounicode=1

\usepackage{amsmath, amsfonts, amssymb, amsthm, mathtools}
\usepackage{icomma}
\usepackage{multicol}

\usepackage{titlesec}	% for sections

\usepackage[left=2.54cm, right=2.54cm, top=2.54cm, bottom=2.54cm]{geometry}

\usepackage[ampersand]{easylist}

\usepackage{hyperref}

% Theorem
\makeatletter
\def\th@plain{%
	\thm@notefont{}% same as heading font
	\itshape % body font
}
\def\th@definition{%
	\thm@notefont{}% same as heading font
	\normalfont % body font
}
\makeatother

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}

\newenvironment{capsproof}[1][\proofname]{\proof[\scshape #1:]}{\endproof}


\title{Fully homomorphic encryption \\ \vspace{2mm} {\large Testing and comparison to RSA}}
\author{V. Rakovtsii, O. Redko, S. Kurilo, V. Shyika}
\date{\today}


% % Commands
\newcommand{\ndash}{\nobreakdash --}
\newcommand{\sectionbreak}{\clearpage} % sections on new pages

\newcommand{\bb}[1]{\mathbb{#1}}
\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\tfr}[1]{\textfrak{#1}}
\newcommand{\tsf}[1]{\textsf{#1}}
\newcommand{\tbf}[1]{\textbf{#1}}
\newcommand{\tss}[1]{\textsubscript{#1}}

\newcommand*\xor{\mathbin{\oplus}}

% % Styles

% Paragraph (Sans, before and after 2ex)
\newenvironment{sfparagraph}{
	\vspace{2ex}\noindent\sffamily\nolinebreak
}{\vspace{2ex}}

% Paragraph (bold, before and after 2ex)
\newenvironment{bparagraph}[1]{
	\vspace{2ex}\noindent\tbf{#1. }\nolinebreak 
}{\vspace{2ex}}

% List
\newenvironment{defaultlist}{
	\begin{easylist}
		\ListProperties(Hide=100, Hang=true, Progressive=2ex, Style*=-- , Style2*=$\bullet$ )
	}{\end{easylist}}

% Paragraphs with name (sfparagraph) and list (defaultlist)
\newenvironment{algorithm}[1]{
	\begin{sfparagraph}
		#1
	\end{sfparagraph}
	\begin{defaultlist}
	}{\end{defaultlist}}

\begin{document}
	
	\clearpage
	\maketitle
	\thispagestyle{empty}
	
	\clearpage
	\thispagestyle{empty}
	\begin{abstract}
		Very small abstract.
	\end{abstract}
	
	
	\tableofcontents
	
	
	\section{Introduction}
	
	A fully homomorphic public key encryption scheme has been a “holy grail” of cryptography for a very long time.
	In the last year this problem has been solved by Gentry, by using properties of ideal lattices. 
	Various cryptographic schemes make use of lattices, sometimes just to argue about their security (such as NTRU), in other cases lattices are vital to understand the workings of the scheme algorithms. 
	Gentry’s fully homomorphic scheme falls into the latter category.
	In this paper we present a fully homomorphic scheme which can be described using the elementary theory of algebraic number fields, and hence we do not require lattices to understand its encryption and decryption operations. However, our scheme does fall into the category of schemes whose best known attack is based on lattices.
	At a high level our scheme is very simple, and is mainly parametrized by an integer $N$ (there are other parameters which are less important). The public key consists of a prime p and an integer $\alpha$ modulo~$p$.
	The private key consists of either an integer $z$ (if we are encrypting bits), or an integer polynomial $Z(x)$ of degree $N - 1$ (if we are encrypting general binary polynomials of degree $N - 1$).
	To encrypt a message one encodes the message as a binary polynomial, then one randomizes the message by adding on two times a small random polynomial.
	To obtain the ciphertext, the resulting polynomial is evaluated at $\alpha$ modulo~$p$.
	As such, the ciphertext is simply an integer modulo~$p$ (irrespective of whether we are encrypting bits or binary polynomials of degree $N - 1$).
	To decrypt in the case where we know the message is a single bit, we multiply the ciphertext by $z$ and divide by $p$. 
	We then round this rational number to the nearest integer value, and subtract the result from the ciphertext. 
	The plaintext is then recovered by reducing this intermediate result modulo~2. 
	When we are decrypting a binary polynomial we follow the same procedure, but this time we multiply by the polynomial $Z(x)$ and divide by $p$, to obtain a rational polynomial. 
	Rounding the coefficients of this polynomial to the nearest integer, subtracting from the original ciphertext, and reducing modulo two will result again in recovering the plaintext.
	
	Craig Gentry using lattice-based cryptography showed the first fully homomorphic encryption scheme as announced by IBM on June~25, 2009. 
	His scheme supports evaluations of arbitrary depth circuits. 
	His construction starts from a \emph{somewhat homomorphic} encryption scheme using ideal lattices that is limited to evaluating low-degree polynomials over encrypted data. 
	(It is limited because each ciphertext is noisy in some sense, and this noise grows as one adds and multiplies ciphertexts, until ultimately the noise makes the resulting ciphertext indecipherable.) 
	He then shows how to modify this scheme to make it \emph{bootstrappable} --- in particular, he shows that by modifying the somewhat homomorphic scheme slightly, it can actually evaluate its own decryption circuit, a self-referential property. 
	Finally, he shows that any bootstrappable somewhat homomorphic encryption scheme can be converted into a fully homomorphic encryption through a recursive self-embedding. 
	In the particular case of Gentry's ideal-lattice-based somewhat homomorphic scheme, this bootstrapping procedure effectively "refreshes" the ciphertext by reducing its associated noise so that it can be used thereafter in more additions and multiplications without resulting in an indecipherable ciphertext. 
	Gentry based the security of his scheme on the assumed hardness of two problems: certain worst-case problems over ideal lattices, and the sparse (or low-weight) subset sum problem.
	
	Regarding performance, ciphertexts in Gentry's scheme remain compact insofar as their lengths do not depend at all on the complexity of the function that is evaluated over the encrypted data.
	The computational time only depends linearly on the number of operations performed. 
	However, the scheme is impractical for many applications, because ciphertext size and computation time increase sharply as one increases the security level. 
	To obtain $2^k$ security against known attacks, the computation time and ciphertext size are high-degree polynomials in $k$. 
	Stehle and Steinfeld reduced the dependence on $k$ substantially. 
	They presented optimizations that permit the computation to be only quasi\ndash $k^{3.5}$ per boolean gate of the function being evaluated.
	
	Gentry's Ph.D. thesis provides additional details. 
	Gentry also published a high-level overview of the van~Dijk et al. construction (described below) in the March~2010 issue of Communications of the ACM.
	
	\section{Preliminaries}
	\subsection{Notation}
	
	Given a polynomial $g(x)=\sum_{i=0}^{t}{g_i x^i} \in \bb{Q}[x]$, we define the 2\ndash norm and $\infty$\ndash norm as
	\[
	\|g(x)\|_2 = \sqrt{\sum_{i=0}^{t}{g_i^2}} \text{ and } \|g(x)\|=\max_{i=0, \dots, t} |g_i|.
	\] %
	For a positive value $r$, we define two corresponding types of “ball” centered at the origin:
	\begin{align*}
	\mc{B}_{2,N}(r)&=\left\{ \sum_{i=0}^{N-1}{a_i x^i} : \sum_{i=0}^{N-1}{a_i^2 \le r^2} \right\},\\
	\mc{B}_{\infty,N}(r)&=\left\{ \sum_{i=0}^{N-1}{a_i x^i} : {-r \le a_i \le r} \right\}.
	\end{align*}
	We have the usual inclusions $\mc{B}_{2,N}(r) \subset \mc{B}_{\infty,N}(r)$ and $\mc{B}_{\infty,N}(r) \subset \mc{B}_{2,N}(\sqrt{N} \cdot r)$.
	We also define the following half-ball:
	\[
	\mc{B}_{\infty,N}^{+}(r)=\left\{ \sum_{i=0}^{N-1}{a_i x^i} : {0 \le a_i \le r} \right\}.
	\] %
	All reductions in this paper modulo an odd integer $m$ are defined to result in a value in the range $[-(m - 1)/2,\ldots, (m - 1)/2]$. 
	The notation $A\leftarrow B$, means assign the value on the left to the value on the right. Whereas $a \leftarrow _R A$ where $A$ is a set, means select $a$ from the set $A$ using a uniform distribution.
	
	\subsection{Ideals in Number Fields}
	
	Since the underlying workings of our scheme are based on prime ideals in a number field, we first recap on some basic properties.
	
	Let $K$ be a number field $\bb{Q}[\theta]$ where $\theta$ is a root of a monic irreducible polynomial $F(x) \in \bb{Z}[x]$ of degree $N$.
	Consider the equation order $\bb{Z}[\theta]$ inside the ring of integers $\mc{O}_K$.
	For our parameter choices we typically have $\mc{O}_K = \bb{Z}[\theta]$, but this need not be the case in general.
	Our scheme works with ideals in $\bb{Z}[\theta]$ that are assumed coprime with the index $\mc{O}_K: \bb{Z}[\theta]$, so there is little difference with working in $\mc{O}_K$.
	These ideals can be represented in one of two ways, either by an $N$\ndash dimensional $\bb{Z}$\ndash basis or as a two element $\bb{Z}[\theta]$\ndash basis.
	When presenting an ideal $\tfr{a}$ as an $N$\ndash dimensional $\bb{Z}$ basis we give $N$ elements $\gamma_1, \ldots, \gamma_N \in \bb{Z}[\theta]$, and every element in $\tfr{a}$ is represented by the $\bb{Z}[\theta]$ \ndash module generated by $\gamma_1, \ldots, \gamma_N$.
	It is common practice to present this basis as an $n \times n$\ndash matrix.
	The matrix is then set to be $(\gamma_{i,j})$, where we set $\gamma_i = \sum_{j=0}^{N - 1}{\gamma_{i,j}\theta^j}$, i.e. we take a row oriented formulation. 
	Taking the Hermite Normal Form (HNF) of this basis will
	produce a lower triangular basis in which the leading diagonal $(d_1,\ldots ,d_N)$ satisfies $d_{i+1}\|d_i$.
	
	However, every such ideal can also be represented by a $\bb{Z}[\theta]$\ndash basis given by two elements, $\langle \delta_1, \delta_2 \rangle$.
	In particular one can always select $\delta_1$ to be an integer.
	For ideals lying above a rational prime $p$, it is very easy to write down a two element representation of an ideal.
	If we factor $F(x)$ modulo~$p$ into irreducible
	polynomials
	
	\[
	F(x) = {\prod_{i=1}^{t}{F_i(x)^{e_i}}}\pmod{p}
	\] %
	then, for $p$ not dividing $[\mc{O}_K: \bb{Z}[\theta]]$, the prime ideals dividing $p\bb{Z}[\theta]$ are given by the two element representation
	
	\[
	\tfr{p}_i = \langle p,F_i(\theta) \rangle.
	\]
	
	We define the residue degree of $\tfr{p}_i$ to be equal to the degree $d_i$ of the polynomial $F_i(x)$. Reduction modulo $\tfr{p}_i$ produces a homomorphism
	
	\[
	\iota_{\tfr{p}_i} : \bb{Z}[\theta] \longrightarrow \bb{F}_{p^{d_i}}.
	\]
	
	We will be particularly interested in prime ideals of residue degree one. 
	These can be represented as a two element representation by $\langle p, \theta - \alpha \rangle$ where $p$ is the norm of the ideal and $\alpha$ is a root of $F(x)$ modulo~$p$.
	If $\chi \in \bb{Z}[\theta]$ is given by $\chi = \sum_{i=0}^{N - 1}{c_i \theta^i}$ then the homomorphism $\iota_\tfr{p}$ simply corresponds to evaluation of the polynomial $\chi(\theta)$ in $\alpha$ modulo~$p$.
	
	Given a prime ideal of the form $\langle p, \theta - \alpha \rangle$, the corresponding HNF representation is very simple to construct, and is closely related to the two element	representation, as we shall now show. 
	We need to row reduce the $2N \times N$ matrix
	
	\[
	\begin{pmatrix}
	p & & & & & &\\
	& p & & & 0 & &\\
	& & & \ddots & & &\\
	& 0 & & & & &\\
	& & & & & p &\\
	-\alpha & 1 & & & 0 & &\\
	& -\alpha & 1 & & & &\\
	0 & & & \ddots & \ddots & &\\
	& & & & -\alpha & 1 &\\
	-F_0 & -F_1 & -F_2 & \ldots & -F_{N-2} & -F_{N-1} & -\alpha
	\end{pmatrix}
	\] %
	where $F(x) = \sum_{i=0}^{N}F_i x^i$. It is not hard to see that the HNF of the above matrix is then given by
	
	\[
	\begin{pmatrix}
	p & & & & 0\\
	-\alpha & 1 & & &\\
	-\alpha^2 & & 1 & &\\
	\vdots & & & \ddots &\\
	-\alpha^{N - 1} & & 0 & & 1
	\end{pmatrix},
	\] %
	where all the integers in the first column, in rows two and onward, are taken modulo~$p$.
	
	Recall that an ideal is called principal if it is generated by one element, i.e. we can write $\tfr{p} = \langle \gamma \rangle = \gamma \cdot \bb{Z}[\theta]$.
	Note that given an HNF or two-element representation of an ideal, determining whether it is principal, and finding a generator is considered to be a hard problem for growing $N$. 
	Indeed the best known algorithms (which are essentially equivalent to finding the class and unit group of a number field) run in exponential time in the degree of the field.
	
	\section{Our Somewhat Homomorphic Scheme}
	
	In this section we present our somewhat homomorphic scheme and analyze for which parameter sets decryption works. To simplify the presentation we present the scheme at this point as one which just encrypts elements in $\mc{P} = \{0, 1\}$.
	
	\subsection{The Scheme}
	A somewhat homomorphic encryption scheme consists of five algorithms: \{{\sffamily KeyGen, Encrypt, Decrypt, Add, Mult}\}. 
	We shall describe each in turn; notice that the most complex phase is that of \tsf{KeyGen}. 
	The scheme is parametrized by three values $(N, \eta, \mu)$.
	A typical set of parameters would be  $(N, 2^{\sqrt{N}}, \sqrt{N})$.
	Later we shall return to discussing the effects of the sizes of these values on the security level $\lambda$ and performance of the scheme. 
	
	\begin{algorithm}{KeyGen():}
		& Set the plaintext space to be $\mc{P} = \{0, 1\}$.
		& Choose a monic irreducible polynomial $F(x) \in \bb{Z}[x]$ of degree $N$.
		& Repeat:
		&& $S(x) \leftarrow _R \mc{B}_{\infty,N}(\eta/2) $.
		&& $G(x) \leftarrow 1 + 2 \cdot S(x)$.
		&& $p \leftarrow \tsf{resultant}(G(x),F(x))$.
		& Until $p$ is prime.
		& $D(x) \leftarrow \gcd(G(x),F(x))$ over $\bb{F}_p[x]$.
		& Let $\alpha \in \bb{F}_p$ denote the unique root of $D(x)$.
		& Apply the XGCD\ndash algorithm over $\bb{Q}[x]$ to obtain $Z(x)=\sum_{i=0}^{N - 1}{z_i x^i} \in \bb{Z}[x]$ such that
		\begin{gather*}
		Z(x)\cdot G(x) = p \mod{F(x)}.
		\end{gather*}
		& $B \leftarrow z_0 \pmod{2p}$.
		& The public key is $\tsf{PK}=(p,\alpha)$, whilst the private key is $\tsf{SK} = (p,B)$.
	\end{algorithm}
	
	\begin{multicols}{2}
		\begin{algorithm}{Encrypt$(M, \tsf{PK})$:}
			& Parse \tsf{PK} as $p, \alpha$.
			& If $M \ne \{0, 1\}$ then \tsf{abort}.
			& $R(x) \leftarrow _R \mc{B}_{\infty,N}(\mu /2)$.
			& $C(x) \leftarrow M + 2 \cdot R(x)$.
			& $c \leftarrow C(\alpha) \pmod{p}$.
			& Output $c$.
		\end{algorithm}
		\columnbreak
		\begin{algorithm}{Decrypt$(c, \tsf{SK})$:}
			& Parse \tsf{SK} as $(p,B)$.
			& $M \leftarrow (c - \lfloor c \cdot B/p\rceil) \pmod{2}$.
		\end{algorithm}
	\end{multicols}
	
	\begin{multicols}{2}
		\begin{algorithm}{Add$(c_1, c_2, \tsf{PK})$:}
			& Parse \tsf{PK} as $p, \alpha$.
			& $c_3 \leftarrow (c_1 + c_2) \pmod{p}$.
			& Output $c_3$.
		\end{algorithm}
		\columnbreak
		\begin{algorithm}{Mult$(c_1, c_2, \tsf{PK})$:}
			& Parse \tsf{PK} as $p, \alpha$.
			& $c_3 \leftarrow (c_1 \cdot c_2) \pmod{p}$.
			& Output $c_3$.
		\end{algorithm}
	\end{multicols}
	
	\subsection{Analysis}
	In this section we analyze for which parameter sets our scheme is correct and also determine how many homomorphic operations can be performed before decryption will fail.
	
	% Style paragraph with bold name (after par 2ex)
	\newenvironment{paralgorithm}[1]{\noindent\tbf{#1}}{\vspace{2ex}}
	
	\begin{paralgorithm}{\tsf{KeyGen} algorithm.}
		We can see that \tsf{KeyGen} generates an element $\gamma = G(\theta)$ of prime norm $p$ in the number field $K$ defined by $F(x)$. 
		As such we have constructed a small generator of the degree one prime ideal $\tfr{p} = \gamma \cdot \bb{Z}[\theta]$. 
		To find the two element representation of $\tfr{p}$, we need to select the correct root $\alpha$ of $F(x)$ modulo~$p$.
		Since $\gamma = G(\theta) \in \tfr{p}$ we have that $G(\alpha) \equiv 0 \mod{p}$, so $G(x)$ and $F(x)$ have at least one common root modulo~$p$. 
		Furthermore, there will be precisely one root in common, since otherwise $\gamma$ would generate two different prime ideals, which clearly is impossible. 
		This explains the fact that $D(x)$ has degree one; we are using $D(x)$ to select the precise root of $F(x)$ which corresponds to the ideal~\tfr{p} generated by~$\gamma$. 
		The two element representation of the ideal~\tfr{p} then simply is $\tfr{p} = p \cdot \bb{Z}[\theta] + (\theta - \alpha)\bb{Z}[\theta]$.
	\end{paralgorithm}
	
	
	\begin{paralgorithm}{\tsf{Encrypt} algorithm.}
		The message $M$ is added to twice a small random polynomial $R(x)$ resulting in a polynomial $C(x)$. 
		The $\infty$\ndash norm of the polynomial $R(x)$ is controlled by the parameter $\mu$. 
		Encryption then simply equals reduction of $C(\theta)$ modulo~$p$ using the public two element representation $\langle p, \theta - \alpha\rangle$.
		As explained before, this simply corresponds to evaluating $C(x)$ in $\alpha$ modulo~$p$. Furthermore, note that this precisely implies that $C(\theta) - c \in \tfr{p}$.
	\end{paralgorithm}
	
	\begin{paralgorithm}{\tsf{Decrypt} algorithm.}
		By definition of encryption, we have that $C(\theta) - c \in \tfr{p}$ and $\tfr{p}$ is principal and generated by $\gamma = G(\theta)$. Hence, we can write
		\[
		C(\theta) - c = q(\theta) \cdot \gamma
		\]
		with $q(\theta) \in \bb{Z}(\theta)$. It is clear that if we recover the element $C(\theta)$, then decryption
		will work since $C(\theta) = M + 2 \cdot R(\theta)$. Note that $\gamma^{-1}$ is precisely given by $Z(\theta)/p$, where $Z$ was computed in \tsf{KeyGen}. Dividing by $\gamma$ therefore leads to the following equality
		\[
		-c \cdot Z(\theta)/p = q(\theta)-(C(\theta) \cdot Z(\theta))/p.
		\]
		The above equation shows that if $\|C(\theta) \cdot Z(\theta)/p\|_\infty < 1/2$, then simply rounding the coefficients of $-c \cdot Z(\theta)/p$ will result in the correct quotient $q(\theta)$. 
		This will allow for correct decryption by computing $C(\theta) = c + q(\theta) \cdot \gamma$. The crucial part therefore is to obtain a bound on $\|Z(x)\|_\infty$.
	\end{paralgorithm}
	
	\begin{paralgorithm}{\tsf{Add} and \tsf{Mult} algoritms.}
		It is clear that both algorithms are correct. However, we need to consider how the error values propagate as we apply \tsf{Add} and \tsf{Mult}. 
		In particular, decryption of $c = C(\alpha)$ will work for a polynomial $C(x)$ if $C(x) \in \mc{B}_{\infty,N}(\tsf{r}_\tsf{Dec})$. 
		However, as we apply \tsf{Add} and \tsf{Mult} to a ciphertext the value of $C(x)$ starts to lie in balls of larger and larger radius. 
		As soon as	 $C(x) \not\in \mc{B}_{\infty,N}(\tsf{r}_\tsf{Dec})$, we are no longer guaranteed to be able to decrypt correctly.
		This is why our basic scheme is only somewhat homomorphic, since we are only
		able to apply \tsf{Add} and \tsf{Mult} a limited number of times.
		
		Let $c_1$ and $c_2$ denote two ciphertexts, corresponding to two randomizations $C_1(x) = M_1 + N_1(x)$ and $C_2(x) = M_2 + N_2(x)$; where $M_i \in \{0, 1\}$ are the messages and $N_i(x) \in \mc{B}_{\infty,N}(r_i - 1)$ is the randomness, i.e. $C_i(x) \in \mc{B}_{\infty,N}(r_i)$. 
		We let
		\begin{align*}
		C_3(x) &= M_3 + N_3(x) = (M_1 + N_1(x)) + (M_2 + N_2(x)),\\
		C_4(x) &= M_4 + N_4(x) = (M_1+ N_1(x)) \cdot (M_2 + N_2(x)),
		\end{align*} %
		where $M_3, M_4 \in \{0, 1\}$. Then
		\[
		C_3(x) \in \mc{B}_{\infty, N}(r_1 + r_2)
		\]
		and
		\[
		C_4(x) \in \mc{B}_{\infty, N}(\delta_\infty \cdot r_1 \cdot r_2).
		\]
		Initially we start with a ciphertext with $C(x)$ lying in $\mc{B}_{\infty, N}(\mu + 1)$.
		After executing a circuit with multiplicative depth d, we expect the ciphertext to correspond to a polynomial $C'(x)$ lying in a ball $\mc{B}_{\infty, N}(r)$ with
		\[
		r \approx (\delta_\infty \cdot \mu)^{2^d}.
		\]
		Thus we can only decrypt the output of such a circuit if $r \leqslant \tsf{r}_\tsf{Dec}$, i.e.
		\begin{align*}
		d \log 2 &\leqslant \log{\log \tsf{r}_\tsf{Dec}} - \log{\log (\delta_\infty \cdot \mu)} 
		\\ &\approx \log{\log{\left(\frac{\sqrt{N} \cdot n}{2 \cdot \delta_\infty}\right)}} - \log{\log(\delta_\infty \cdot \mu)}.
		\end{align*}
	\end{paralgorithm}
	
	\section{Security Analysis}
	
	We consider three aspects of security; key recovery, onewayness of the encryption and semantic security. 
	Whilst semantic security is based on what might at first appear a non-traditional problem, the other two notions of security are related to well studied problems in number theory. 
	This is similar to other notions in cryptography; for example key recovery in ElGamal is related to the DLP problem,
	and semantic security to the relatively obscure (for mathematicians) DDH problem. 
	However, we first show that our scheme is in some sense a specialization and optimization of Gentry's scheme.
	
	\begin{bparagraph}{Link With Gentry's Scheme.}
		To discuss the security in more detail, we first show that our scheme is a specialization and simplification of the lattice based scheme of Gentry. 
		The generator $\gamma$ in our scheme is  equivalent to the private basis of the ideal $J$ in Gentry's scheme, the public basis is then the two element  representation $\langle p, \theta - \alpha \rangle$. 
		The ideal $I$ of Gentry's scheme is simply set to the principal ideal $\langle 2 \rangle$. 
		Therefore, we see that KeyGen is a specialized form of KeyGen for Gentry's scheme: in particular we use the compact two element representation $\langle p, \alpha \rangle$ of the public basis, instead of the larger HNF  representation as Gentry does.
		
		We now turn to the encryption algorithm. 
		The element $C(\theta) = M(\theta) + 2 \cdot R(\theta)$
		is precisely the value of $\psi '$ computed in Gentry's encryption algorithm, with a value of $\tsf{r}_\tsf{Enc}$ (in the 2\ndash norm) equal to $\sqrt{N \cdot} \mu$.
		Gentry then produces his ciphertext	$\psi '$ by reducing $\psi '$ modulo the ideal $J$ using the HNF basis.
		It is at this point	that we seem to depart from Gentry's presentation: we actually compute the reduction of $\psi '$ modulo~\tfr{p} using the public two element representation.
		Given $\psi '$ as a polynomial in $\theta$, this involves replacing $\theta$ by $\alpha$ and reducing the result
		modulo~\tfr{p}. So given $C(x)$, we produce $c$ by simply computing $c = \iota_\tfr{p}(C(\theta)) \in F_p.$
		However, given our earlier discussion on the HNF of the ideal given by $\langle p, \theta - \alpha \rangle$	we see that the two reduction algorithms are equivalent when we are working in	the equation order $\bb{Z}(\theta)$.
		
		Hence, we conclude that our scheme is a specialisation of Gentry's scheme. 
		For the given pecialisation our key sizes are much smaller than Gentry's, whilst our ciphertexts are the same size. When compared to the full generality of Gentry's scheme our ciphertexts are also much smaller than Gentry's. 
		The link between the two schemes, and the relative simplicity of our scheme, may help shed light on parameter choices in Gentry's original scheme.
	\end{bparagraph}
	
	\begin{bparagraph}{Key Recovery}
		Recall the public key in our scheme consists of a principal degree one prime ideal in two element representation, whilst the private key consists of the inverse of a small generator of this principal prime ideal. 
		To see that the generator $\gamma$ is small, notice that the polynomial $G(x)$ has an $\infty$\ndash norm given roughly by $\eta$, whereas the size of $p$ is roughly $\sqrt{N}^N \eta ^ N \cdot \|F\|^{N - 1}_2$. 
		Recovering the private key given the public key is therefore an instance of the small principal ideal problem:
		
		\begin{definition}[Small Principal Ideal Problem (SPIP)]
			Given a principal ideal \tfr{a} in either two element or HNF representation compute a \textquotedblleft small\textquotedblright generator of the ideal.
		\end{definition}
		
		This is one of the core problems in computational number theory and has formed the basis of previous cryptographic proposals. There are currently two approaches to the above problem.
		The first approach is a deterministic method based on the Baby-Step/Giant-Step method.
		This takes time
		\[N^{O(N)} \cdot \sqrt{\min{(A, R)}} \cdot |\Delta|^{o(1)},\]
		where $\Delta$ is the discriminant of $\bb{Z}[\theta]$, $R$ is the regulator and $A = \min^{N}_{i=1} \log{|\gamma^{(i)}|}$ is the minimal logarithmic embedding of $\gamma$. 
		Clearly $A$ can itself be bounded by $\eta$, a minor detail which we leave to the reader.
		
		The second approach to this problem is via Buchmann's sub-exponential algorithm for units and class groups.
		This method has complexity
		\[
		\exp{\left(O(N \log N) \cdot \sqrt{\log{(\Delta)} \cdot \log{\log{(\Delta)}}} \right)},
		\]
		where again $\Delta$ is the discriminant of the order $\bb{Z}[\theta]$.
		However, this method is	likely to produce a generator of large height, i.e. with large coefficients.
		Indeed so large, that writing the obtained generator down as a polynomial in $\theta$ may take exponential time.
		
		In conclusion determining the private key given only the public key is an instance of a classical and well studied problem in algorithmic number theory.
		In particular there are no efficient solutions for this problem, and the only sub-exponential method does not find a solution which is equivalent to our private key.
		
	\end{bparagraph}
	
	\begin{bparagraph}{Onewayness of Encryption}
		In this section we consider the problem of recovering a message given a ciphertext element.
		It is readily seen that this is	equivalent to solving the following problem: Given $p$ and $\alpha, c \in \bb{F}_p $ find $x_i$ for $i = 0,\dots, N - 1$, such that
		\[
		\sum_{i=0}^{N - 1}{x_i \cdot \alpha^i} = c - k \cdot p,
		\]
		where $x_i \leqslant \tsf{r}_\tsf{Dec}$, for some integer value of $k$.
		
		To recast this as a lattice problem, consider the lattice generated by the rows of the matrix $H$ given earlier.
		Consider the lattice vector
		\[
		(k, -x_1,\dots, -x_n) \cdot H = (c-x_0, -x_1,\dots, -x_n).
		\]
		This is a lattice vector which is very close (within \tsf{r\tss{Dec}} the $\infty$\ndash norm, or $\sqrt{N} \cdot \tsf{r}_\tsf{Dec}$ in the 2\ndash norm) to the non-lattice vector $(c, 0,\dots, 0)$. Hence, determining the underlying plaintext given the ciphertext is an instance of the closest vector problem.
		
		However, the underlying lattice is a well-studied lattice in algorithmic number theory.
		A lattice generated by a matrix such as $H$, namely a matrix in Hermite Normal Form in which all but one diagonal entry is equal to one, is probably the most studied	lattice problem from the computational perspective in number theory.
		Thus whilst we are unable to make use of modern worst-case/average-case reductions for our scheme, the underlying lattice problem is well studied.
		
		However, for later use, we will recap on the analysis Gentry has given for this problem. 
		Although one should bear in mind that Gentry's analysis is for a general lattice arising from the HNF of an ideal and not for the specific one in our
		scheme.
		The best known attack on Gentry's scheme is one of lattice reduction, related to the bounded distance decoding problem (BDDP). 
		In particular it is	related to finding short/closest vectors within a multiplicative factor of \tsf{r\tss{Dec}/r\tss{Enc}} in a lattice of dimension $N$. If we set
		\[
		2^\epsilon = \frac{\tsf{r}_\tsf{Dec}}{\tsf{r}_\tsf{Enc}} = \frac{\sqrt{N} \cdot \eta}{2 \cdot \delta_\infty \cdot \mu},
		\]
		then it is believed that solving BDDP has difficulty $2^{N/\epsilon}$.
		We shall refer to the value $2^{N/\epsilon}$ the security level of our somewhat homomorphic scheme.
	\end{bparagraph}
	
	\begin{bparagraph}{Semantic Security}
		Finally we discuss the semantic security of our somewhat homomorphic encryption scheme. 
		Consider the following distinguishing problem:
		\begin{definition}[Polynomial Coset Problem (PCP)]
			he challenger first	selects $b \leftarrow _R \{0, 1\}$ and runs {\normalfont \tsf{KeyGen}} as above to obtain a value of $\alpha$ and $p$. If $b = 0$ then the challenger performs
			\begin{defaultlist}
				& $R(x) \leftarrow _R \mc{B}_{\infty, N}({\normalfont \tsf{r}_\tsf{Enc}})$.
				& $r \leftarrow R(\alpha) \pmod{p}$.
			\end{defaultlist}
			\noindent
			Whilst if $b = 1$ the challenger performs
			\begin{defaultlist}
				& $r \leftarrow _R \bb{F}_p$.
			\end{defaultlist}
			\noindent
			Given ${\normalfont (r, \tsf{PK})}$ the problem is to guess whether $b = 0$ or $b = 1$.
		\end{definition}
		\noindent
		We call the problem the Polynomial Coset Problem as it is akin to Gentry's Ideal Coset Problem.
		The problem basically says one cannot determine	whether $r$ is the evaluation of some small polynomial at $\alpha$ or is a random value modulo~$p$.
		Note that the size of the space $\bb{B}_{\infty,N}(\tsf{r}_\tsf{Enc})$ is roughly $\tsf{r}_\tsf{Enc}^N$, whereas $\bb{F}_p$ size $\eta^N$. 
		So if \tsf{r\tss{Enc}} is much smaller than $\eta$, we are trying to distinguish a relatively small space within a larger one.
		Note, in the case where $b = 0$ we generate the value $R(x)$ from $\mc{B}_{\infty, N}(\tsf{r}_\tsf{Enc})$ as opposed to $\mc{B}_{\infty, N}(\tsf{r}_\tsf{Dec})$, since we are interested in arguing about semantic security for what are the simplest ciphertexts to break.
		
		\begin{theorem}
			Suppose there is an algorithm $\mc{A}$ which breaks the semantic security of our somewhat homomorphic scheme with advantage $\epsilon$. Then there is an algorithm $\mc{B}$, running in about the same time as $\mc{A}$, which solves the PCP with advantage $\epsilon/2$.
		\end{theorem}
		
		
		\begin{capsproof}
			The algorithm $\mc{B}$ creates a challenge ciphertext for algorithm $\mc{A}$ from its own challenge $(r, \tsf{PK})$ by setting
			\[
			c \leftarrow (M_\beta(\alpha) + 2 \cdot r) \pmod{p},
			\]
			where $M_0$ and $M_1$ are $\mc{A}$'s two challenge messages and $\beta \leftarrow _R \{0, 1\}$ is $\mc{B}$'s choice of a challenge bit. $\mc{A}$ sends back a guess $\beta '$ for $\beta$ and $\mc{B}$ returns $\beta \xor \beta '$.
			
			When $b = 0$ in the PCP problem, it is clear that the challenge ciphertext $c$ has the correct distribution, so $\mc{B}$ obtains the same advantage as $\mc{A}$, namely $\epsilon$.
			When $b = 1$, $r$ is uniformly random modulo~$p$ and since $p$ is odd, $2r$ is uniformly random modulo~$p$ and therefore so is $c$.
			Hence, the advantage of $\mc{A}$ is 0, which implies that $\mc{B}$'s overall advantage is $\epsilon/2$.
		\end{capsproof}
		
	\end{bparagraph}
	
	
\end{document}
