% !TeX spellcheck = en_US

\documentclass[a4paper, 12pt]{article}

\usepackage{amsmath, amssymb}
\usepackage{cmap}
\usepackage{icomma}
\usepackage{titlesec}	% for sections
\usepackage{yfonts}
\usepackage[left=2.54cm, right=2.54cm, top=2.54cm, bottom=2.54cm]{geometry}

\input glyphtounicode
\pdfgentounicode=1

\newcommand{\ndash}{\nobreakdash --}
\newcommand{\sectionbreak}{\clearpage} % sections on new pages


\title{Fully homomorphic encryption \\ \vspace{2mm} {\large Testing and comparison to RSA}}
\author{V. Rakovtsii, O. Redko, S. Kurilo, V. Shyika}
\date{\today}

\begin{document}
	
	\clearpage
	\maketitle
	\thispagestyle{empty}
	
	
	\clearpage
	\thispagestyle{empty}
	\begin{abstract}
	Very small abstract.
	\end{abstract}
	
	
	\tableofcontents
	
	
	\section{Introduction}

	A fully homomorphic public key encryption scheme has been a “holy grail” of cryptography for a very long time.
	In the last year this problem has been solved by Gentry, by using properties of ideal lattices. Various cryptographic schemes make use of lattices, sometimes just to argue about their security (such as NTRU), in other cases lattices are vital to understand the workings of the scheme algorithms. Gentry’s fully homomorphic scheme falls into the latter category.
	In this paper we present a fully homomorphic scheme which can be described using the elementary theory of algebraic number fields, and hence we do not require lattices to understand its encryption and decryption operations. However, our scheme does fall into the category of schemes whose best known attack is based on lattices.
	At a high level our scheme is very simple, and is mainly parametrized by an integer $N$ (there are other parameters which are less important). The public key consists of a prime p and an integer $\alpha$ modulo $p$.
	The private key consists of either an integer $z$ (if we are encrypting bits), or an integer polynomial $Z(x)$ of degree $N - 1$ (if we are encrypting general binary polynomials of degree $N - 1$).
	To encrypt a message one encodes the message as a binary polynomial, then one randomizes the message by adding on two times a small random polynomial.
	To obtain the ciphertext, the resulting polynomial is evaluated at $\alpha$ modulo~$p$.
	As such, the ciphertext is simply an integer modulo~$p$ (irrespective of whether we are encrypting bits or binary polynomials of degree $N - 1$).
	To decrypt in the case where we know the message is a single bit, we multiply the ciphertext by $z$ and divide by $p$. We then round this rational number to the nearest integer value, and subtract the result from the ciphertext. 
	The plaintext is then recovered by reducing this intermediate result modulo~2. 
	When we are decrypting a binary polynomial we follow the same procedure, but this time we multiply by the polynomial $Z(x)$ and divide by $p$, to obtain a rational polynomial. 
	Rounding the coefficients of this polynomial to the nearest integer, subtracting from the original ciphertext, and reducing modulo two will result again in recovering the plaintext.
	
	Craig Gentry using lattice-based cryptography showed the first fully homomorphic encryption scheme as announced by IBM on June~25, 2009. 
	His scheme supports evaluations of arbitrary depth circuits. 
	His construction starts from a \textit{somewhat homomorphic} encryption scheme using ideal lattices that is limited to evaluating low-degree polynomials over encrypted data. 
	(It is limited because each ciphertext is noisy in some sense, and this noise grows as one adds and multiplies ciphertexts, until ultimately the noise makes the resulting ciphertext indecipherable.) 
	He then shows how to modify this scheme to make it \textit{bootstrappable} --- in particular, he shows that by modifying the somewhat homomorphic scheme slightly, it can actually evaluate its own decryption circuit, a self-referential property. 
	Finally, he shows that any bootstrappable somewhat homomorphic encryption scheme can be converted into a fully homomorphic encryption through a recursive self-embedding. 
	In the particular case of Gentry's ideal-lattice-based somewhat homomorphic scheme, this bootstrapping procedure effectively "refreshes" the ciphertext by reducing its associated noise so that it can be used thereafter in more additions and multiplications without resulting in an indecipherable ciphertext. 
	Gentry based the security of his scheme on the assumed hardness of two problems: certain worst-case problems over ideal lattices, and the sparse (or low-weight) subset sum problem.
	
	Regarding performance, ciphertexts in Gentry's scheme remain compact insofar as their lengths do not depend at all on the complexity of the function that is evaluated over the encrypted data.
	The computational time only depends linearly on the number of operations performed. However, the scheme is impractical for many applications, because ciphertext size and computation time increase sharply as one increases the security level. 
	To obtain $2^k$ security against known attacks, the computation time and ciphertext size are high-degree polynomials in $k$. Stehle and Steinfeld reduced the dependence on $k$ substantially. 
	They presented optimizations that permit the computation to be only quasi\ndash $k^{3.5}$ per boolean gate of the function being evaluated.
	
	Gentry's Ph.D. thesis provides additional details. Gentry also published a high-level overview of the van~Dijk et al. construction (described below) in the March~2010 issue of Communications of the ACM.
	
	\section{Preliminaries}
	\subsection{Notation}
	
	Given a polynomial $g(x)=\sum_{i=0}^{t}{g_i x^i} \in \mathbb{Q}[x]$ , we define the 2\ndash norm and $\infty$\ndash norm as
	\[
		\|g(x)\|_2 = \sqrt{\sum_{i=0}^{t}{g_i^2}} \text{ and } \|g(x)\|=\max_{i=0, \dots, t} |g_i|.
	\] %
	For a positive value $r$, we define two corresponding types of “ball” centered at	the origin:
	\begin{align*}
		\mathcal{B}_{2,N}(r)&=\left\{ \sum_{i=0}^{N-1}{a_i x^i} : \sum_{i=0}^{N-1}{a_i^2 \le r^2} \right\},\\
		\mathcal{B}_{\infty,N}(r)&=\left\{ \sum_{i=0}^{N-1}{a_i x^i} : {-r \le a_i \le r} \right\}.
	\end{align*}
	We have the usual inclusions $\mathcal{B}_{2,N}(r) \subset \mathcal{B}_{\infty,N}(r)$ and $\mathcal{B}_{\infty,N}(r) \subset \mathcal{B}_{2,N}(\sqrt{N} \cdot r)$.
	We also define the following half-ball:
	\[
		\mathcal{B}_{\infty,N}^{+}(r)=\left\{ \sum_{i=0}^{N-1}{a_i x^i} : {0 \le a_i \le r} \right\}.
	\] %
	All reductions in this paper modulo an odd integer m are defined to result in a value in the range $[−(m - 1)/2,\ldots, (m − 1)/2]$. The notation $A\leftarrow B$, means assign the value on the left to the value on the right. Whereas $a \leftarrow _R A$ where $A$ is a set, means select $a$ from the set $A$ using a uniform distribution.
	
	\subsection{Ideals in Number Fields}
	
	Since the underlying workings of our scheme are based on prime ideals in a number field, we first recap on some basic properties.
	
	\newcommand{\bb}[1]{\mathbb{#1}}
	\newcommand{\mc}[1]{\mathcal{#1}}
	
	Let $K$ be a number field $\bb{Q}[\theta]$ where $\theta$ is a root of a monic irreducible polynomial $F(x) \in \bb{Z}[x]$ of degree $N$.
	Consider the equation order $\bb{Z}[\theta]$ inside the ring of integers $\mc{O}_K$.
	For our parameter choices we typically have $\mc{O}_K = \bb{Z}[\theta]$, but this need not be the case in general.
	Our scheme works with ideals in $\bb{Z}[\theta]$ that are assumed coprime with the index $\mc{O}_K: \bb{Z}[\theta]$, so there is little difference with working in $\mc{O}_K$.
	These ideals can be represented in one of two ways, either by an $N$\ndash dimensional $\bb{Z}$\ndash basis or as a two element $\bb{Z}[\theta]$\ndash basis.
	When presenting an ideal $\textfrak{a}$ as an $N$\ndash dimensional $\bb{Z}$ basis we give $N$ elements $\gamma_1, \ldots, \gamma_N \in \bb{Z}[\theta]$, and every element in $\textfrak{a}$ is represented by the $\bb{Z}[\theta]$ \ndash module generated by $\gamma_1, \ldots, \gamma_N$.
	It is common practice to present this basis as an $n \times n$\ndash matrix.
	The matrix is then set to be $(\gamma_{i,j})$, where we set $\gamma_i = \sum_{j=0}^{N - 1}{\gamma_{i,j}\theta^j}$, i.e. we take a row oriented formulation. Taking the Hermite Normal Form (HNF) of this basis will
	produce a lower triangular basis in which the leading diagonal $(d_1,\ldots ,d_N)$ satisfies $d_{i+1}\|d_i$.
	
	However, every such ideal can also be represented by a $\bb{Z}[\theta]$\ndash basis given by two elements, $\langle \delta_1, \delta_2 \rangle$. In particular one can always select $\delta_1$ to be an integer.
	For ideals lying above a rational prime $p$, it is very easy to write down a two element representation of an ideal. If we factor $F(x)$ modulo $p$ into irreducible
	polynomials
	
	\[
		F(x) = {\prod_{i=1}^{t}{F_i(x)^{e_i}}}\pmod{p}
	\] %
	then, for $p$ not dividing $[\mc{O}_K: \bb{Z}[\theta]]$, the prime ideals dividing $p\bb{Z}[\theta]$ are given by the two element representation
	
	\[
		\textfrak{p}_i = \langle p,F_i(\theta) \rangle
	\].
	
	We define the residue degree of $\textfrak{p}_i$ to be equal to the degree $d_i$ of the polynomial $F_i(x)$. Reduction modulo $\textfrak{p}_i$ produces a homomorphism
	
	\[
		\iota_{\textfrak{p}_i} : \bb{Z}[\theta] \longrightarrow \bb{F}_{p^{d_i}}
	\].
	
	We will be particularly interested in prime ideals of residue degree one. 
	These can be represented as a two element representation by $\langle p, \theta - \alpha \rangle$ where $p$ is the norm of the ideal and $\alpha$ is a root of $F(x)$ modulo $p$.
	If $\chi \in \bb{Z}[\theta]$ is given by $\chi = \sum_{i=0}^{N - 1}{c_i \theta^i}$ then the homomorphism $\iota_\textfrak{p}$ simply corresponds to evaluation of the polynomial $\chi(\theta)$ in $\alpha$ modulo~$p$.
	
	Given a prime ideal of the form $\langle p, \theta - \alpha \rangle$, the corresponding HNF representation is very simple to construct, and is closely related to the two element
	representation, as we shall now show. We need to row reduce the $2N \times N$ matrix
	
	\[
		\begin{pmatrix}
		p & & & & & &\\
		& p & & & 0 & &\\
		& & & \ddots & & &\\
		& 0 & & & & &\\
		& & & & & p &\\
		-\alpha & 1 & & & 0 & &\\
		& -\alpha & 1 & & & &\\
		0 & & & \ddots & \ddots & &\\
		& & & & -\alpha & 1 &\\
		-F_0 & -F_1 & -F_2 & \ldots & -F_{N-2} & -F_{N-1} & -\alpha
		\end{pmatrix}
	\] %
	where $F(x) = \sum_{i=0}^{N}F_i x^i$. It is not hard to see that the HNF of the above matrix is then given by
	
	\[
		\begin{pmatrix}
		p & & & & 0\\
		-\alpha & 1 & & &\\
		-\alpha^2 & & 1 & &\\
		\vdots & & & \ddots &\\
		-\alpha^{N - 1} & & 0 & & 1
		\end{pmatrix},
	\] %
	where all the integers in the first column, in rows two and onward, are taken modulo $p$.
	
	Recall that an ideal is called principal if it is generated by one element, i.e. we can write $\textfrak{p} = \langle \gamma \rangle = \gamma \cdot \bb{Z}[\theta]$.
	Note that given an HNF or two-element representation of an ideal, determining whether it is principal, and finding a generator is considered to be a hard problem for growing $N$. Indeed the best known algorithms (which are essentially equivalent to finding the class and unit group of a number field) run in exponential time in the degree of the field.
	
	\section{Our Somewhat Homomorphic Scheme}
	
	In this section we present our somewhat homomorphic scheme and analyze for which parameter sets decryption works. To simplify the presentation we present the scheme at this point as one which just encrypts elements in $\mc{P} = \{0, 1\}$.
	
	\subsection{The Scheme}
	
\end{document}
