% !TEX root = ../main.tex
% !TeX encoding = utf8


\section{Our Somewhat Homomorphic Scheme}

In this section we present our somewhat homomorphic scheme and analyze for which parameter sets decryption works. To simplify the presentation we present the scheme at this point as one which just encrypts elements in $\mc{P} = \{0, 1\}$.

\subsection{The Scheme}

A somewhat homomorphic encryption scheme consists of five algorithms: \{\tsf{KeyGen, Encrypt, Decrypt, Add, Mult}\}. 
We shall describe each in turn; notice that the most complex phase is that of \tsf{KeyGen}. 
The scheme is parametrized by three values $(N, \eta, \mu)$.
A typical set of parameters would be  $(N, 2^{\sqrt{N}}, \sqrt{N})$.
Later we shall return to discussing the effects of the sizes of these values on the security level $\lambda$ and performance of the scheme. 

\begin{textalgorithm}{KeyGen():}
	& Set the plaintext space to be $\mc{P} = \{0, 1\}$.
	& Choose a monic irreducible polynomial $F(x) \in \bb{Z}[x]$ of degree $N$.
	& Repeat:
	&& $S(x) \leftarrow _R \mc{B}_{\infty,N}(\eta/2) $.
	&& $G(x) \leftarrow 1 + 2 \cdot S(x)$.
	&& $p \leftarrow \tsf{resultant}(G(x),F(x))$.
	& Until $p$ is prime.
	& $D(x) \leftarrow \gcd(G(x),F(x))$ over $\bb{F}_p[x]$.
	& Let $\alpha \in \bb{F}_p$ denote the unique root of $D(x)$.
	& Apply the XGCD\ndash algorithm over $\bb{Q}[x]$ to obtain $Z(x)=\sum_{i=0}^{N-1}{z_i x^i} \in \bb{Z}[x]$ such that
	\begin{gather*}
	Z(x)\cdot G(x) = p \mod{F(x)}.
	\end{gather*}
	& $B \leftarrow z_0 \pmod{2p}$.
	& The public key is $\tsf{PK}=(p, \alpha)$, whilst the private key is $\tsf{SK} = (p,B)$.
\end{textalgorithm}

\begin{multicols}{2}
	\begin{textalgorithm}{Encrypt$(M, \tsf{PK})$:}
		& Parse \tsf{PK} as $p, \alpha$.
		& If $M \ne \{0, 1\}$ then \tsf{abort}.
		& $R(x) \leftarrow _R \mc{B}_{\infty, N}(\mu /2)$.
		& $C(x) \leftarrow M+2 \cdot R(x)$.
		& $c \leftarrow C(\alpha) \pmod{p}$.
		& Output $c$.
	\end{textalgorithm}
	\columnbreak
	\begin{textalgorithm}{Decrypt$(c, \tsf{SK})$:}
		& Parse \tsf{SK} as $(p,B)$.
		& $M \leftarrow (c - \lfloor c \cdot B/p \rceil) \pmod{2}$.
	\end{textalgorithm}
\end{multicols}

\begin{multicols}{2}
	\begin{textalgorithm}{Add$(c_1, c_2, \tsf{PK})$:}
		& Parse \tsf{PK} as $p, \alpha$.
		& $c_3 \leftarrow (c_1+c_2) \pmod{p}$.
		& Output $c_3$.
	\end{textalgorithm}
	\columnbreak
	\begin{textalgorithm}{Mult$(c_1, c_2, \tsf{PK})$:}
		& Parse \tsf{PK} as $p, \alpha$.
		& $c_3 \leftarrow (c_1 \cdot c_2) \pmod{p}$.
		& Output $c_3$.
	\end{textalgorithm}
\end{multicols}

\subsection{Analysis}

In this section we analyze for which parameter sets our scheme is correct and also determine how many homomorphic operations can be performed before decryption will fail.

% Style paragraph with bold name (after par 2ex)
\newenvironment{paralgorithm}[1]{\noindent\tbf{#1}}{\vspace{2ex}}

\begin{paralgorithm}{\tsf{KeyGen} algorithm.}
	We can see that \tsf{KeyGen} generates an element $\gamma = G(\theta)$ of prime norm $p$ in the number field $K$ defined by $F(x)$. 
	As such we have constructed a small generator of the degree one prime ideal $\tfr{p} = \gamma \cdot \bb{Z}[\theta]$. 
	To find the two element representation of $\tfr{p}$, we need to select the correct root $\alpha$ of $F(x)$ modulo~$p$.
	Since $\gamma = G(\theta) \in \tfr{p}$ we have that $G(\alpha) \equiv 0 \mod{p}$, so $G(x)$ and $F(x)$ have at least one common root modulo~$p$. 
	Furthermore, there will be precisely one root in common, since otherwise $\gamma$ would generate two different prime ideals, which clearly is impossible. 
	This explains the fact that $D(x)$ has degree one; we are using $D(x)$ to select the precise root of $F(x)$ which corresponds to the ideal~\tfr{p} generated by~$\gamma$. 
	The two element representation of the ideal~\tfr{p} then simply is $\tfr{p} = p \cdot \bb{Z}[\theta] + (\theta - \alpha)\bb{Z}[\theta]$.
\end{paralgorithm}

\begin{paralgorithm}{\tsf{Encrypt} algorithm.}
	The message $M$ is added to twice a small random polynomial $R(x)$ resulting in a polynomial $C(x)$. 
	The $\infty$\ndash norm of the polynomial $R(x)$ is controlled by the parameter $\mu$. 
	Encryption then simply equals reduction of $C(\theta)$ modulo~$p$ using the public two element representation $\langle p, \theta - \alpha\rangle$.
	As explained before, this simply corresponds to evaluating $C(x)$ in $\alpha$ modulo~$p$.
	Furthermore, note that this precisely implies that $C(\theta)-c \in \tfr{p}$.
\end{paralgorithm}

\begin{paralgorithm}{\tsf{Decrypt} algorithm.}
	By definition of encryption, we have that $C(\theta)-c \in \tfr{p}$ and $\tfr{p}$ is principal and generated by $\gamma = G(\theta)$.
	Hence, we can write
	\[
	C(\theta)-c = q(\theta) \cdot \gamma
	\]
	with $q(\theta) \in \bb{Z}(\theta)$. It is clear that if we recover the element $C(\theta)$, then decryption will work since $C(\theta) = M+2 \cdot R(\theta)$.
	Note that $\gamma^{-1}$ is precisely given by $Z(\theta)/p$, where $Z$ was computed in \tsf{KeyGen}.
	Dividing by $\gamma$ therefore leads to the following equality
	\[
	-c \cdot Z(\theta)/p = q(\theta) - (C(\theta) \cdot Z(\theta))/p.
	\]
	The above equation shows that if $\| C(\theta) \cdot Z(\theta)/p \|_\infty < 1/2$, then simply rounding the coefficients of $-c \cdot Z(\theta)/p$ will result in the correct quotient $q(\theta)$.
	This will allow for correct decryption by computing $C(\theta) = c+q(\theta) \cdot \gamma$.
	The crucial part therefore is to obtain a bound on $\| Z(x) \|_\infty$.
\end{paralgorithm}

\begin{paralgorithm}{\tsf{Add} and \tsf{Mult} algoritms.}
	It is clear that both algorithms are correct. However, we need to consider how the error values propagate as we apply \tsf{Add} and \tsf{Mult}. 
	In particular, decryption of $c = C(\alpha)$ will work for a polynomial $C(x)$ if $C(x) \in \mc{B}_{\infty, N}(\tsf{r}_\tsf{Dec})$. 
	However, as we apply \tsf{Add} and \tsf{Mult} to a ciphertext the value of $C(x)$ starts to lie in balls of larger and larger radius. 
	As soon as $C(x) \not\in \mc{B}_{\infty, N}(\tsf{r}_\tsf{Dec})$, we are no longer guaranteed to be able to decrypt correctly.
	This is why our basic scheme is only somewhat homomorphic, since we are only able to apply \tsf{Add} and \tsf{Mult} a limited number of times.
	
	Let $c_1$ and $c_2$ denote two ciphertexts, corresponding to two randomizations $C_1(x) = M_1+N_1(x)$ and $C_2(x) = M_2+N_2(x)$; where $M_i \in \{0, 1\}$ are the messages and $N_i(x) \in \mc{B}_{\infty, N}(r_i-1)$ is the randomness, i.e. $C_i(x) \in \mc{B}_{\infty, N}(r_i)$. 
	We let
	\begin{align*}
	C_3(x) &= M_3+N_3(x) = (M_1+N_1(x)) + (M_2+N_2(x)),\\
	C_4(x) &= M_4+N_4(x) = (M_1+N_1(x)) \cdot (M_2+N_2(x)),
	\end{align*} %
	where $M_3, M_4 \in \{0, 1\}$. Then
	\[
	C_3(x) \in \mc{B}_{\infty, N}(r_1+r_2)
	\]
	and
	\[
	C_4(x) \in \mc{B}_{\infty, N}(\delta_\infty \cdot r_1 \cdot r_2).
	\]
	Initially we start with a ciphertext with $C(x)$ lying in $\mc{B}_{\infty, N}(\mu + 1)$.
	After executing a circuit with multiplicative depth d, we expect the ciphertext to correspond to a polynomial $C'(x)$ lying in a ball $\mc{B}_{\infty, N}(r)$ with
	\[
	r \approx (\delta_\infty \cdot \mu)^{2^d}.
	\]
	Thus we can only decrypt the output of such a circuit if $r \leqslant \tsf{r}_\tsf{Dec}$, i.e.
	\begin{align*}
	d \log 2 &\leqslant \log{\log{\tsf{r}_\tsf{Dec}}} - \log{\log{(\delta_\infty \cdot \mu)}} 
	\\ &\approx \log{\log{\left(\frac{\sqrt{N} \cdot n}{2 \cdot \delta_\infty}\right)}} - \log{\log{(\delta_\infty \cdot \mu)}}.
	\end{align*}
\end{paralgorithm}
